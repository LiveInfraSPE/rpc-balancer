// Code generated by go generate; DO NOT EDIT.
package rpc

import (
	"context"
	"fmt"

	"github.com/ethereum/go-ethereum/rpc"
)


func (rp *Client) RegisterName(name string, receiver interface{}) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.RegisterName(name, receiver)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) SupportedModules() (map[string]string, error) {

	
	results, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0, r1 := client.SupportedModules()
		
		return []interface{}{ r0, r1 }, r1
		
		
	}, 2)
	if err != nil {
		
			
			return map[string]string{}, err
			
		
	}
	
	
	var ok bool
	
	
	r0, ok := results[0].(map[string]string); if !ok { return map[string]string{}, fmt.Errorf("invalid type for r0") }
	
		
			
			return r0, nil
			
		
	
}

func (rp *Client) SetHeader(key,value string) () {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		client.SetHeader(key, value)
		return nil, nil
		
	}, 0)
	if err != nil {
		
			
			return
			
		
	}
	
	return
	
}

func (rp *Client) Call(result interface{}, method string, args ...interface{}) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.Call(result, method, args...)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.CallContext(ctx, result, method, args...)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) BatchCall(b []rpc.BatchElem) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.BatchCall(b)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) BatchCallContext(ctx context.Context, b []rpc.BatchElem) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.BatchCallContext(ctx, b)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) Notify(ctx context.Context, method string, args ...interface{}) (error) {

	
	_, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.Notify(ctx, method, args...)
		
		return []interface{}{ r0 }, r0
		
		
	}, 1)
	if err != nil {
		
			
			return err
			
		
	}
	
	
	
		
			
			return nil
			
		
	
}

func (rp *Client) EthSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*rpc.ClientSubscription, error) {

	
	results, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0, r1 := client.EthSubscribe(ctx, channel, args...)
		
		return []interface{}{ r0, r1 }, r1
		
		
	}, 2)
	if err != nil {
		
			
			return nil, err
			
		
	}
	
	
	var ok bool
	
	
	r0, ok := results[0].(*rpc.ClientSubscription); if !ok { return nil, fmt.Errorf("invalid type for r0") }
	
		
			
			return r0, nil
			
		
	
}

func (rp *Client) Subscribe(ctx context.Context, namespace string, channel interface{}, args ...interface{}) (*rpc.ClientSubscription, error) {

	
	results, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0, r1 := client.Subscribe(ctx, namespace, channel, args...)
		
		return []interface{}{ r0, r1 }, r1
		
		
	}, 2)
	if err != nil {
		
			
			return nil, err
			
		
	}
	
	
	var ok bool
	
	
	r0, ok := results[0].(*rpc.ClientSubscription); if !ok { return nil, fmt.Errorf("invalid type for r0") }
	
		
			
			return r0, nil
			
		
	
}

func (rp *Client) SupportsSubscriptions() (bool) {

	
	results, err := rp.retry(func(client *rpc.Client) ([]interface{}, error) {
	
		
		r0 := client.SupportsSubscriptions()
		
		return []interface{}{ r0 }, nil
		
		
	}, 1)
	if err != nil {
		
			
			return false
			
		
	}
	
	
	var ok bool
	
	
	r0, ok := results[0].(bool); if !ok { return false }
	
		
			
			return r0
			
		
	
}

